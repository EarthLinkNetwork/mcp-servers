import { CartItem, GeneratedConfig, ClaudeConfig, CursorConfig, VSCodeConfig } from '@/types/mcp'

export function generateConfigurations(cartItems: CartItem[]): GeneratedConfig {
  const claudeConfig: ClaudeConfig = {
    mcpServers: {}
  }

  const cursorConfig: CursorConfig = {
    mcpServers: {}
  }

  const vscodeConfig: VSCodeConfig = {
    "modelcontextprotocol.servers": {}
  }

  let envTemplate = '# MCP Server Environment Variables\n'
  envTemplate += '# Generated by MCP Hub\n\n'

  cartItems.forEach(({ server, envValues }) => {
    const serverKey = server.name

    // Generate command based on package name
    const command = `npx ${server.package_name}`
    
    // Process args and env from config template
    const args = server.config_template?.args || []
    const templateEnv = server.config_template?.env || {}

    // Replace template variables with actual values or keep as-is
    const processedArgs = Array.isArray(args) ? args.map((arg: unknown) => {
      if (typeof arg === 'string' && arg.startsWith('${') && arg.endsWith('}')) {
        const envKey = arg.slice(2, -1)
        return envValues[envKey] || arg
      }
      return String(arg)
    }) : []

    const processedEnv: Record<string, string> = {}
    if (templateEnv && typeof templateEnv === 'object' && !Array.isArray(templateEnv)) {
      Object.entries(templateEnv).forEach(([key, value]) => {
        if (typeof value === 'string' && value.startsWith('${') && value.endsWith('}')) {
          const envKey = value.slice(2, -1)
          processedEnv[key] = envValues[envKey] || value
        } else {
          processedEnv[key] = String(value)
        }
      })
    }

    // Claude Code configuration
    claudeConfig.mcpServers![serverKey] = {
      command,
      args: processedArgs.length > 0 ? processedArgs : undefined,
      env: Object.keys(processedEnv).length > 0 ? processedEnv : undefined
    }

    // Cursor configuration (same as Claude Code)
    cursorConfig.mcpServers![serverKey] = {
      command,
      args: processedArgs.length > 0 ? processedArgs : undefined,
      env: Object.keys(processedEnv).length > 0 ? processedEnv : undefined
    }

    // VS Code configuration
    vscodeConfig["modelcontextprotocol.servers"]![serverKey] = {
      command,
      args: processedArgs.length > 0 ? processedArgs : undefined,
      env: Object.keys(processedEnv).length > 0 ? processedEnv : undefined
    }

    // Environment template
    if (server.environment_variables && server.environment_variables.length > 0) {
      envTemplate += `# ${server.display_name} (${server.package_name})\n`
      server.environment_variables.forEach(envVar => {
        if (envVar.description) {
          envTemplate += `# ${envVar.description}\n`
        }
        const value = envVar.example ? `# Example: ${envVar.example}` : ''
        envTemplate += `${envVar.name}=${value}\n`
      })
      envTemplate += '\n'
    }
  })

  return {
    claudeCode: claudeConfig,
    cursor: cursorConfig,
    vscode: vscodeConfig,
    envTemplate
  }
}

export function downloadConfig(config: unknown, filename: string, type: 'json' | 'env' = 'json') {
  let content: string
  let mimeType: string

  if (type === 'json') {
    content = JSON.stringify(config, null, 2)
    mimeType = 'application/json'
  } else {
    content = String(config)
    mimeType = 'text/plain'
  }

  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  
  URL.revokeObjectURL(url)
}